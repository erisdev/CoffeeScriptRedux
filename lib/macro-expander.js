// Generated by CoffeeScript 2.0.0-beta9-dev
var addMacroParameters, callFunc, Compiler, envEnrichments, escodegen, evalInGlobalContext, execNode, exports, fs, getCalleeName, getFunc, getLocation, nodeToId, nodeTypes, transform, union, unwrap, walk;
fs = require('fs');
escodegen = require('escodegen');
Compiler = require('./compiler').Compiler;
union = require('./functional-helpers').union;
envEnrichments = require('./helpers').envEnrichments;
nodeTypes = require('./nodes');
exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
evalInGlobalContext = eval;
getFunc = function (ast) {
  var cache$, code, func, jsAST, map;
  jsAST = Compiler.compile(ast, { bare: true }).toBasicObject();
  cache$ = escodegen.generate(jsAST, {
    sourceMapWithCode: true,
    sourceMap: '(macro)'
  });
  map = cache$.map;
  code = cache$.code;
  func = evalInGlobalContext('(' + code + ')');
  func.sourceMap = map;
  return func;
};
callFunc = function (func, obj, args, useLocation, name) {
  var e;
  if (null == args)
    args = [];
  try {
    return func.apply(obj, args);
  } catch (e$) {
    e = e$;
    if (e instanceof SyntaxError)
      throw e;
    e.srcMap = func.sourceMap;
    throw e;
  }
};
callFunc.stopStackTrace = true;
execNode = function (node, context, bindings) {
  var args, funcNode, k, params, v;
  if (null != bindings) {
    params = [];
    args = [];
    for (k in bindings) {
      v = bindings[k];
      params.push(k);
      args.push(v);
    }
  }
  funcNode = new nodeTypes.Function(null != params ? params : '', node);
  return callFunc(getFunc(funcNode), context, args);
};
nodeToId = function (node, dotted) {
  if (null == dotted)
    dotted = false;
  if (node instanceof nodeTypes.Identifier) {
    return node.data;
  } else if (dotted && node instanceof nodeTypes.StaticMemberAccessOps) {
    return '' + nodeToId(node.expression) + '.' + node.memberName;
  } else {
    return void 0;
  }
};
getCalleeName = function (node) {
  if (node instanceof nodeTypes.FunctionApplications)
    return nodeToId(node['function'], true);
};
getLocation = function (node) {
  var loc;
  if (null != node.line)
    return loc = {
      line: this.line = node.line,
      column: this.column = node.column,
      offset: node.offset
    };
};
addMacroParameters = function (node) {
  node.parameters.unshift(new nodeTypes.Identifier('cs'));
  node.parameters.unshift(new nodeTypes.Identifier('macro'));
  return node;
};
unwrap = function (node) {
  if (null != node.body) {
    return unwrap(node.body);
  } else if ((null != node.statements ? node.statements.length : void 0) === 1) {
    return unwrap(node.statements[0]);
  } else {
    return node;
  }
};
transform = function () {
  var _handleReturn;
  _handleReturn = function (node, res, nullOK) {
    if (res === true) {
      return node;
    } else if (res instanceof nodeTypes.Nodes) {
      return res;
    } else if (nullOK) {
      return void 0;
    } else {
      return new nodeTypes.Undefined;
    }
  };
  return transform = function (node, visit) {
    var child, childName, res;
    node = node.clone();
    for (var i$ = 0, length$ = node.childNodes.length; i$ < length$; ++i$) {
      childName = node.childNodes[i$];
      if (!(null != node[childName]))
        continue;
      if (in$(childName, node.listMembers)) {
        node[childName] = function (accum$) {
          for (var i$1 = 0, length$1 = node[childName].length; i$1 < length$1; ++i$1) {
            child = node[childName][i$1];
            res = child;
            while (res instanceof nodeTypes.Nodes) {
              child = transform(res, visit);
              res = visit(child);
            }
            if (!(res === true))
              continue;
            accum$.push(child);
          }
          return accum$;
        }.call(this, []);
      } else {
        res = child = node[childName];
        while (res instanceof nodeTypes.Nodes) {
          child = transform(res, visit);
          res = visit(child);
        }
        if (res === true) {
          node[childName] = child;
        } else {
          node[childName] = new nodeTypes.Undefined;
        }
      }
    }
    return node;
  };
}();
walk = function (node, visit) {
  var child, childName;
  for (var i$ = 0, length$ = node.childNodes.length; i$ < length$; ++i$) {
    childName = node.childNodes[i$];
    if (!(null != node[childName]))
      continue;
    if (in$(childName, node.listMembers)) {
      for (var i$1 = 0, length$1 = node[childName].length; i$1 < length$1; ++i$1) {
        child = node[childName][i$1];
        visit(walk(child, visit));
      }
    } else {
      child = node[childName];
      visit(walk(child, visit));
    }
  }
  return node;
};
exports.MacroExpander = function () {
  MacroExpander.expand = function (this$) {
    return function (csAst, options) {
      var fn, macro, name;
      if (null == options)
        options = {};
      macro = new this$;
      if (null != options.macros)
        for (name in options.macros) {
          fn = options.macros[name];
          macro.defineMacro(name, fn);
        }
      return macro.expand(csAst, options);
    };
  }(MacroExpander);
  MacroExpander.prototype.builtinMacros = {
    macro: function (macro, cs, node) {
      var name;
      if (node instanceof cs.Function) {
        if (node.parameters.length)
          throw new Error('macro expects a closure with no parameters');
        return callFunc(getFunc(addMacroParameters(node)), this, [
          macro,
          cs
        ], '(macro)');
      } else if (null != (name = getCalleeName(node))) {
        if (!(node['arguments'].length === 1 && node['arguments'][0] instanceof cs.Function))
          throw new Error('macro expects a closure after identifier');
        this.__macros[name] = getFunc(addMacroParameters(node['arguments'][0]));
        return false;
      } else {
        throw new Error('macro expects a closure or identifier');
      }
    },
    'macro.quote': function (macro, cs, func) {
      if (!(func instanceof cs.Function) || func.parameters.length)
        throw new Error('macro.codeToNode expects a closure with no parameters');
      this.__codeNodes.push(func.body);
      return macro.parse('@__codeNodes[' + (this.__codeNodes.length - 1) + ']');
    }
  };
  MacroExpander.prototype.helpers = {
    require: require,
    nodeToId: nodeToId,
    transform: transform,
    walk: walk,
    'eval': function (node, context) {
      if (null == context)
        context = this.__context;
      if (null != node)
        return execNode(node, context);
    },
    uneval: function (obj) {
      var item, key, node, value;
      if (obj instanceof nodeTypes.Nodes) {
        return obj;
      } else if (obj === void 0) {
        return new nodeTypes.Undefined;
      } else if (obj === null) {
        return new nodeTypes.Null;
      } else {
        switch (typeof obj) {
        case 'boolean':
          return new nodeTypes.Bool(obj);
        case 'number':
          return new nodeTypes.Float(obj);
        case 'string':
          return new nodeTypes.String(obj);
        case 'object':
          if (Array.isArray(obj)) {
            return new nodeTypes.ArrayInitialiser(function (accum$) {
              for (var i$ = 0, length$ = obj.length; i$ < length$; ++i$) {
                item = obj[i$];
                accum$.push(this.uneval(item));
              }
              return accum$;
            }.call(this, []));
          } else {
            return new nodeTypes.ObjectInitialiser(function (accum$1) {
              for (key in obj) {
                value = obj[key];
                if (!(node = this.uneval(value)))
                  continue;
                accum$1.push(new nodeTypes.ObjectInitialiserMember(new nodeTypes.String(key), node));
              }
              return accum$1;
            }.call(this, []));
          }
        default:
          return new nodeTypes.Undefined;
        }
      }
    },
    parse: function () {
      var parse;
      parse = null;
      return function (code, inputSource) {
        var cache$;
        if (null == inputSource)
          inputSource = '(macro)';
        if (!(null != parse)) {
          cache$ = require('./module');
          parse = cache$.parse;
          cache$;
        }
        return unwrap(parse(code, {
          inputSource: inputSource,
          raw: true
        }));
      };
    }(),
    parseFile: function (filename) {
      var code;
      code = fs.readFileSync(filename, 'utf8');
      if (code.charCodeAt(0) === 65279)
        code = code.substr(1);
      return this.parse(code, filename);
    },
    backquote: function (values, ast) {
      return transform(ast, function (this$) {
        return function (node) {
          var name;
          if ((name = this$.nodeToId(node)) && values.hasOwnProperty(name)) {
            return this$.uneval(values[name]);
          } else {
            return true;
          }
        };
      }(this));
    }
  };
  function MacroExpander() {
    this.macros = Object.create(this.builtinMacros);
    this.context = {
      __macros: this.macros,
      __codeNodes: []
    };
  }
  MacroExpander.prototype.defineMacro = function (name, fn) {
    return this.macros[name] = fn;
  };
  MacroExpander.prototype.loadMacroDefinitions = function (ast) {
    walk(ast, function (this$) {
      return function (node) {
        var arg, args;
        if (getCalleeName(node) === 'macro') {
          args = [
            this$.helpers,
            nodeTypes
          ].concat([].slice.call(function (accum$) {
            for (var i$ = 0, length$ = node['arguments'].length; i$ < length$; ++i$) {
              arg = node['arguments'][i$];
              accum$.push(this.expand(arg));
            }
            return accum$;
          }.call(this$, [])));
          return callFunc(this$.macros.macro, this$.context, args, getLocation(node), 'macro');
        }
      };
    }(this));
    return this;
  };
  MacroExpander.prototype.expand = function (ast) {
    return transform(ast, function (this$) {
      return function (node) {
        var args, e, name;
        if (null != (name = getCalleeName(node)) && this$.macros.hasOwnProperty(name) || this$.builtinMacros.hasOwnProperty(name)) {
          args = [
            this$.helpers,
            nodeTypes
          ].concat([].slice.call(node['arguments']));
          try {
            return callFunc(this$.macros[name], this$.context, args, getLocation(node), name);
          } catch (e$) {
            e = e$;
            console.log(require('util').inspect(node.toBasicObject(), { depth: 999 }));
            throw e;
          }
        } else {
          return true;
        }
      };
    }(this));
  };
  return MacroExpander;
}();
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}
