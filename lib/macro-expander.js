// Generated by CoffeeScript 2.0.0-beta9-dev
var Compiler, envEnrichments, escodegen, evalAsFile, exports, fs, getCalleeName, hideFromStackTrace, k, nextId, nodeToId, nodeTypes, SourceMapConsumer, terminateStackTrace, transform, union, unwrap, v, vm, walk;
fs = function () {
  try {
    return require('fs');
  } catch (e$) {
    return;
  }
}.call(this);
vm = function () {
  try {
    return require('vm');
  } catch (e$1) {
    return;
  }
}.call(this);
escodegen = require('escodegen');
SourceMapConsumer = require('source-map').SourceMapConsumer;
Compiler = require('./compiler').Compiler;
union = require('./functional-helpers').union;
envEnrichments = require('./helpers').envEnrichments;
nodeTypes = require('./nodes');
exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
hideFromStackTrace = function (func) {
  func.hideFromStackTrace = true;
  return func;
};
terminateStackTrace = function (func) {
  func.terminateStackTrace = true;
  return func;
};
evalAsFile = hideFromStackTrace(function () {
  if (null != vm) {
    return function (code, filename) {
      return vm.runInThisContext('(' + code + ')', filename);
    };
  } else {
    return function () {
      var eval_;
      eval_ = eval;
      return function (code, filename) {
        return eval_('(' + code + ')\n//@ sourceURL=' + filename);
      };
    }();
  }
}());
nodeToId = function (node, dotted) {
  if (null == dotted)
    dotted = false;
  if (node instanceof nodeTypes.Identifier) {
    return node.data;
  } else if (dotted && node instanceof nodeTypes.StaticMemberAccessOps) {
    return '' + nodeToId(node.expression) + '.' + node.memberName;
  } else {
    return void 0;
  }
};
getCalleeName = function (node) {
  if (node instanceof nodeTypes.FunctionApplications)
    return nodeToId(node['function'], true);
};
unwrap = function (node) {
  if (null != node.body) {
    return unwrap(node.body);
  } else if ((null != node.statements ? node.statements.length : void 0) === 1) {
    return unwrap(node.statements[0]);
  } else {
    return node;
  }
};
transform = hideFromStackTrace(function () {
  var _handleReturn;
  _handleReturn = function (node, res, nullOK) {
    if (res === true) {
      return node;
    } else if (res instanceof nodeTypes.Nodes) {
      return res;
    } else if (nullOK) {
      return void 0;
    } else {
      return new nodeTypes.Undefined;
    }
  };
  return transform = function (node, visit) {
    var child, childName, res;
    node = node.clone();
    for (var i$ = 0, length$ = node.childNodes.length; i$ < length$; ++i$) {
      childName = node.childNodes[i$];
      if (!(null != node[childName]))
        continue;
      if (in$(childName, node.listMembers)) {
        node[childName] = function (accum$) {
          for (var i$1 = 0, length$1 = node[childName].length; i$1 < length$1; ++i$1) {
            child = node[childName][i$1];
            res = child;
            while (res instanceof nodeTypes.Nodes) {
              child = transform(res, visit);
              res = visit(child);
            }
            if (!(res === true))
              continue;
            accum$.push(child);
          }
          return accum$;
        }.call(this, []);
      } else {
        res = child = node[childName];
        while (res instanceof nodeTypes.Nodes) {
          child = transform(res, visit);
          res = visit(child);
        }
        if (res === true) {
          node[childName] = child;
        } else {
          node[childName] = new nodeTypes.Undefined;
        }
      }
    }
    return node;
  };
}());
walk = hideFromStackTrace(function (node, visit) {
  var child, childName;
  for (var i$ = 0, length$ = node.childNodes.length; i$ < length$; ++i$) {
    childName = node.childNodes[i$];
    if (!(null != node[childName]))
      continue;
    if (in$(childName, node.listMembers)) {
      for (var i$1 = 0, length$1 = node[childName].length; i$1 < length$1; ++i$1) {
        child = node[childName][i$1];
        visit(walk(child, visit));
      }
    } else {
      child = node[childName];
      visit(walk(child, visit));
    }
  }
  return node;
});
exports.MacroExpander = function () {
  MacroExpander.expand = function (this$) {
    return function (csAst, options) {
      var fn, macro, name;
      if (null == options)
        options = {};
      macro = new this$;
      if (null != options.macros)
        for (name in options.macros) {
          fn = options.macros[name];
          macro.defineMacro(name, fn);
        }
      return macro.expand(csAst, options);
    };
  }(MacroExpander);
  MacroExpander.prototype.builtinMacros = {
    macro: function (node) {
      var bindMacro, name;
      bindMacro = function (this$) {
        return function (node, name) {
          return this$.getFunc(node, name, {
            macro: this$.helpers,
            cs: nodeTypes
          });
        };
      }(this);
      if (node instanceof nodeTypes.Function) {
        if (node.parameters.length)
          throw new Error('macro expects a closure with no parameters');
        return this.callMacro(bindMacro(node), []);
      } else if (null != (name = getCalleeName(node))) {
        if (!(node['arguments'].length === 1 && node['arguments'][0] instanceof nodeTypes.Function))
          throw new Error('macro expects a closure after identifier');
        this.macros[name] = bindMacro(node['arguments'][0], name);
        return false;
      } else {
        throw new Error('macro expects a closure or identifier');
      }
    },
    'macro.quote': function (func) {
      if (!(func instanceof nodeTypes.Function) || func.parameters.length)
        throw new Error('macro.codeToNode expects a closure with no parameters');
      this.context.__codeNodes.push(func.body);
      return this.helpers.parse('@__codeNodes[' + (this.context.__codeNodes.length - 1) + ']');
    }
  };
  MacroExpander.prototype.builtinHelpers = {
    require: require,
    nodeToId: nodeToId,
    transform: transform,
    unwrap: unwrap,
    walk: walk,
    'eval': function (node, context, bindings) {
      if (null != node)
        return this.execNode(node, context, bindings);
    },
    uneval: function (obj) {
      var item, key, node, value;
      if (obj instanceof nodeTypes.Nodes) {
        return obj;
      } else if (obj === void 0) {
        return new nodeTypes.Undefined;
      } else if (obj === null) {
        return new nodeTypes.Null;
      } else {
        switch (typeof obj) {
        case 'boolean':
          return new nodeTypes.Bool(obj);
        case 'number':
          return new nodeTypes.Float(obj);
        case 'string':
          return new nodeTypes.String(obj);
        case 'object':
          if (Array.isArray(obj)) {
            return new nodeTypes.ArrayInitialiser(function (accum$) {
              for (var i$ = 0, length$ = obj.length; i$ < length$; ++i$) {
                item = obj[i$];
                accum$.push(this.helpers.uneval(item));
              }
              return accum$;
            }.call(this, []));
          } else {
            return new nodeTypes.ObjectInitialiser(function (accum$1) {
              for (key in obj) {
                value = obj[key];
                if (!(node = this.helpers.uneval(value)))
                  continue;
                accum$1.push(new nodeTypes.ObjectInitialiserMember(new nodeTypes.String(key), node));
              }
              return accum$1;
            }.call(this, []));
          }
        default:
          return new nodeTypes.Undefined;
        }
      }
    },
    parse: function () {
      var parse;
      parse = null;
      return function (code, inputSource) {
        var cache$;
        if (null == inputSource)
          inputSource = '(macro)';
        if (!(null != parse)) {
          cache$ = require('./module');
          parse = cache$.parse;
          cache$;
        }
        return unwrap(parse(code, {
          inputSource: inputSource,
          raw: true
        }));
      };
    }(),
    parseFile: function (filename) {
      var code;
      code = fs.readFileSync(filename, 'utf8');
      if (code.charCodeAt(0) === 65279)
        code = code.substr(1);
      return this.helpers.parse(code, filename);
    },
    backquote: function (values, ast) {
      return transform(ast, function (this$) {
        return function (node) {
          var name;
          if ((name = this$.helpers.nodeToId(node)) && values.hasOwnProperty(name)) {
            return this$.helpers.uneval(values[name]);
          } else {
            return true;
          }
        };
      }(this));
    },
    define: function (name, func) {
      return this.defineMacro(name, func);
    },
    call: function (name) {
      var args;
      args = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
      return this.callMacro(name, args);
    }
  };
  function MacroExpander() {
    var bind, k, v;
    bind = function (this$) {
      return function (func) {
        var bound;
        bound = func.bind(this$);
        bound.toString = function () {
          return '// (bound to MacroExpander)\n' + func;
        };
        return bound;
      };
    }(this);
    this.macros = {};
    for (k in this.builtinMacros) {
      v = this.builtinMacros[k];
      this.defineMacro(k, bind(v));
    }
    this.helpers = {};
    for (k in this.builtinHelpers) {
      v = this.builtinHelpers[k];
      this.helpers[k] = bind(v);
    }
    this.filenameStack = [];
    this.filename = '<internal>';
    this.sourceMaps = {};
    this.context = {
      __macros: this.macros,
      __codeNodes: []
    };
  }
  MacroExpander.prototype.defineMacro = function (name, fn) {
    this.macros[name] = fn;
    if (null != fn.displayName)
      fn.displayName;
    else
      fn.displayName = '<macro ' + name + '>';
    return fn;
  };
  MacroExpander.prototype.callMacro = function (name, args) {
    var func;
    if (typeof name === 'function') {
      func = name;
    } else if (name in this.macros) {
      func = this.macros[name];
    } else {
      throw new Error('undefined macro: ' + name);
    }
    return func.apply(this.context, args);
  };
  MacroExpander.prototype.pushFile = function (newFile) {
    if (null == newFile)
      newFile = '<unknown>';
    this.filenameStack.push(this.filename);
    return this.filename = newFile;
  };
  MacroExpander.prototype.popFile = function () {
    return this.filename = this.filenameStack.pop();
  };
  nextId = 0;
  MacroExpander.prototype.getFunc = function (node, name, bindings) {
    var args, cache$, code, csAst, func, jsAST, k, map, params, sourceMapId, v;
    if (null == name)
      name = '<anonymous macro ' + nextId++ + '>';
    params = [];
    args = [];
    if (null != bindings)
      for (k in bindings) {
        v = bindings[k];
        params.push(new nodeTypes.Identifier(k));
        args.push(v);
      }
    csAst = new nodeTypes.Function(params, node);
    jsAST = Compiler.compile(csAst, { bare: true }).toBasicObject();
    cache$ = escodegen.generate(jsAST, {
      sourceMapWithCode: true,
      sourceMap: this.filename
    });
    map = cache$.map;
    code = cache$.code;
    if (map = null != map ? map.toJSON() : void 0) {
      sourceMapId = '' + this.filename + '#' + name;
      this.sourceMaps[sourceMapId] = map;
    }
    func = evalAsFile(code, sourceMapId).apply(null, args);
    func.displayName = '<macro ' + name + '>';
    return func;
  };
  MacroExpander.prototype.execNode = function (node, context, bindings) {
    var funcNode;
    if (null == context)
      context = this.context;
    funcNode = new nodeTypes.Function([], node);
    return this.getFunc(funcNode, null, bindings).call(context);
  };
  MacroExpander.prototype.prepareStackTrace = function (error, stack) {
    var cache$, cache$1, column, filename, frame, func, line, location, map, name;
    return ['' + error.name + ': ' + error.message].concat([].slice.call(function (accum$) {
      for (var i$ = 0, length$ = stack.length; i$ < length$; ++i$) {
        frame = stack[i$];
        func = frame.getFunction();
        name = null != func.displayName ? func.displayName : (cache$ = frame.getFunctionName(), null != cache$ ? cache$ : '<anonymous>');
        filename = frame.getFileName();
        if (func.terminateStackTrace)
          break;
        if (func.hideFromStackTrace)
          continue;
        if (filename in this.sourceMaps) {
          map = new SourceMapConsumer(this.sourceMaps[filename]);
          cache$1 = map.originalPositionFor({
            line: frame.getLineNumber(),
            column: frame.getColumnNumber()
          });
          line = cache$1.line;
          column = cache$1.column;
          location = [
            map.sources[0],
            line,
            column
          ];
        } else {
          location = [null != filename ? filename : '<unknown>'];
        }
        accum$.push('    ' + name + ' (' + location.join(':') + ')');
      }
      return accum$;
    }.call(this, []))).join('\n') + '\n';
  };
  MacroExpander.prototype.loadMacroDefinitions = function (ast) {
    walk(ast, function (this$) {
      return function (node) {
        var arg, args;
        if (getCalleeName(node) === 'macro') {
          args = function (accum$) {
            for (var i$ = 0, length$ = node['arguments'].length; i$ < length$; ++i$) {
              arg = node['arguments'][i$];
              accum$.push(this.expand(arg));
            }
            return accum$;
          }.call(this$, []);
          return this$.callMacro('macro', args);
        }
      };
    }(this));
    return this;
  };
  MacroExpander.prototype.expand = function (ast, options) {
    var _prepareStackTrace;
    if (!options.fullStackTrace) {
      _prepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = this.prepareStackTrace.bind(this);
    }
    this.pushFile(options.inputSource);
    try {
      ast = transform(ast, terminateStackTrace(function (this$) {
        return function (node) {
          var name;
          if (null != (name = getCalleeName(node)) && this$.macros.hasOwnProperty(name)) {
            return this$.callMacro(name, node['arguments']);
          } else {
            return true;
          }
        };
      }(this)));
    } finally {
      this.popFile();
      if (null != _prepareStackTrace)
        Error.prepareStackTrace = _prepareStackTrace;
    }
    return ast;
  };
  for (k in MacroExpander.prototype) {
    if (!isOwn$(MacroExpander.prototype, k))
      continue;
    v = MacroExpander.prototype[k];
    if (!(typeof v === 'function'))
      continue;
    hideFromStackTrace(v);
  }
  return MacroExpander;
}();
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}
function isOwn$(o, p) {
  return {}.hasOwnProperty.call(o, p);
}
